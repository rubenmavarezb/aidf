// packages/cli/src/utils/config.ts

import type { AidfConfig } from '../types/index.js';

/**
 * Resolves environment variable references in configuration strings.
 * Supports ${VAR} and $VAR syntax.
 * Throws if the referenced variable is not set.
 */
export function resolveConfigValue(value: string): string {
  // Match ${VAR_NAME} syntax
  let resolved = value.replace(/\$\{([A-Za-z_][A-Za-z0-9_]*)\}/g, (_match, varName: string) => {
    const envValue = process.env[varName];
    if (envValue === undefined) {
      throw new Error(`Environment variable "${varName}" is not set (referenced as \${${varName}})`);
    }
    return envValue;
  });

  // Match $VAR_NAME syntax (not preceded by \ or inside ${})
  // Only match standalone $VAR at word boundaries, not already handled ${VAR}
  resolved = resolved.replace(/(?<!\$\{)\$([A-Za-z_][A-Za-z0-9_]*)/g, (_match, varName: string) => {
    const envValue = process.env[varName];
    if (envValue === undefined) {
      throw new Error(`Environment variable "${varName}" is not set (referenced as $${varName})`);
    }
    return envValue;
  });

  return resolved;
}

/**
 * Recursively resolves all environment variable references in a config object.
 * Walks through nested objects and arrays, resolving string values.
 */
export function resolveConfig<T extends object>(config: T): T {
  return resolveValue(config) as T;
}

function resolveValue(value: unknown): unknown {
  if (typeof value === 'string') {
    return resolveConfigValue(value);
  }

  if (Array.isArray(value)) {
    return value.map(item => resolveValue(item));
  }

  if (value !== null && typeof value === 'object') {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value as Record<string, unknown>)) {
      resolved[key] = resolveValue(val);
    }
    return resolved;
  }

  // Numbers, booleans, null, undefined — pass through unchanged
  return value;
}

/**
 * Normalizes a raw config object (from YAML/JSON) into the expected AidfConfig structure.
 * Handles backward compatibility with configs generated by older versions of `aidf init`,
 * which used `behavior.autoCommit` / `behavior.scopeEnforcement` (camelCase) instead of
 * `permissions.auto_commit` / `permissions.scope_enforcement` (snake_case), and
 * `validation.lint` / `validation.typecheck` (keyed) instead of `validation.pre_commit[]` (arrays).
 */
export function normalizeConfig(raw: Record<string, unknown>): AidfConfig {
  const config: Record<string, unknown> = { ...raw };

  // --- Normalize behavior → permissions ---
  const behavior = config.behavior as Record<string, unknown> | undefined;
  if (behavior && !config.permissions) {
    config.permissions = {
      auto_commit: behavior.autoCommit ?? behavior.auto_commit ?? true,
      auto_push: behavior.autoPush ?? behavior.auto_push ?? false,
      auto_pr: behavior.autoPr ?? behavior.auto_pr ?? false,
      scope_enforcement: behavior.scopeEnforcement ?? behavior.scope_enforcement ?? 'ask',
    };
  } else if (behavior && config.permissions) {
    // Merge: behavior values serve as fallbacks for missing permissions fields
    const permissions = config.permissions as Record<string, unknown>;
    if (permissions.auto_commit === undefined && (behavior.autoCommit !== undefined || behavior.auto_commit !== undefined)) {
      permissions.auto_commit = behavior.autoCommit ?? behavior.auto_commit;
    }
    if (permissions.scope_enforcement === undefined && (behavior.scopeEnforcement !== undefined || behavior.scope_enforcement !== undefined)) {
      permissions.scope_enforcement = behavior.scopeEnforcement ?? behavior.scope_enforcement;
    }
  }

  // --- Normalize keyed validation → array-based validation ---
  const validation = config.validation as Record<string, unknown> | undefined;
  if (validation && !Array.isArray(validation.pre_commit) && !Array.isArray(validation.pre_push)) {
    // Old format: { lint: "pnpm lint", typecheck: "pnpm typecheck", test: "pnpm test", build: "pnpm build" }
    // Check if it has old-format keys (lint, typecheck, test, build, format)
    const oldKeys = ['lint', 'typecheck', 'format', 'test', 'build'];
    const hasOldKeys = oldKeys.some(k => typeof validation[k] === 'string');

    if (hasOldKeys) {
      const preCommit: string[] = [];
      const prePush: string[] = [];
      const prePr: string[] = [];

      // lint, typecheck, format → pre_commit
      for (const key of ['lint', 'typecheck', 'format']) {
        if (typeof validation[key] === 'string' && (validation[key] as string).length > 0) {
          preCommit.push(validation[key] as string);
        }
      }
      // test → pre_push
      if (typeof validation.test === 'string' && (validation.test as string).length > 0) {
        prePush.push(validation.test as string);
      }
      // build → pre_pr
      if (typeof validation.build === 'string' && (validation.build as string).length > 0) {
        prePr.push(validation.build as string);
      }

      config.validation = {
        pre_commit: preCommit,
        pre_push: prePush,
        pre_pr: prePr,
      };
    }
  }

  // --- Normalize version ---
  if (typeof config.version === 'string') {
    const parsed = parseFloat(config.version as string);
    if (!isNaN(parsed)) {
      config.version = parsed;
    }
  }

  return config as unknown as AidfConfig;
}

/** Keys in config that are likely to hold secrets */
const SENSITIVE_KEY_PATTERNS = [
  'key',
  'secret',
  'password',
  'token',
  'pass',
  'webhook_url',
];

/**
 * Checks a config object for values that look like plaintext secrets
 * (i.e., sensitive keys whose values don't use ${...} env var syntax).
 * Returns a list of warning messages.
 */
export function detectPlaintextSecrets(
  config: Record<string, unknown>,
  path: string[] = []
): string[] {
  const warnings: string[] = [];

  for (const [key, value] of Object.entries(config)) {
    const currentPath = [...path, key];

    if (typeof value === 'string' && value.length > 0) {
      const keyLower = key.toLowerCase();
      const isSensitiveKey = SENSITIVE_KEY_PATTERNS.some(pattern => keyLower.includes(pattern));
      const usesEnvVar = /\$\{[A-Za-z_][A-Za-z0-9_]*\}/.test(value) || /^\$[A-Za-z_][A-Za-z0-9_]*$/.test(value);

      if (isSensitiveKey && !usesEnvVar) {
        warnings.push(
          `Possible plaintext secret at "${currentPath.join('.')}". Consider using an environment variable: \${ENV_VAR_NAME}`
        );
      }
    } else if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
      warnings.push(
        ...detectPlaintextSecrets(value as Record<string, unknown>, currentPath)
      );
    }
  }

  return warnings;
}
